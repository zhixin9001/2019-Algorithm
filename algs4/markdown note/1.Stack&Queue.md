
[TOC]
#### 栈
下压栈（简称栈）是一种基于后进后出（LIFO）策略的集合类型。这里学习分别用数组和链表这两种基础数据结构来实现栈。
栈支持的基本操作有push,pop。
##### 可变长数组实现
要用数组实现栈，可以声明一个int型的标记，这个标记指向的位置即为栈顶，push操作时，将值放在数据中标记的位置，同时将标记+1，pop时，返回数组在标记位置的值，同时标记-1。
但java中的数组在声明的时候其长度就已经固定了，所以栈使用的空间只能是这个数组最大容量的一部分。为了能容纳更多的数据而声明一个特别大的数组会非常浪费空间，那如何解决这个问题，达到既不会浪费数组空间也不会超出数组范围呢？
可以采用动态调整数组大小的方式，在push操作导致栈已满时，重新创建一个数组，其容量为原数组的两倍。同理在pop操作使数组的闲置空间达到一定程度时，重新创建一个容量更小的数组。但闲置的判断标准不能为一半1/2，否则会造成在1/2的临界点处push和pop操作时发生“抖动”，即频繁地进行数组扩容、缩容操作，这会极大地降低栈的性能。所以通常的做法是在减少到数组容量的1/4时缩容为1/2。

实现可变长数组的代码如下：
```
public class StackResizeArray<Item>  {
	private Item[] a; // array of items
	private int n; // number of elements on stack

	public StackResizeArray() {
		a = (Item[]) new Object[2];
		n = 0;
	}

	public boolean isEmpty() {
		return n == 0;
	}

	public int size() {
		return n;
	}

	private void resize(int capacity) {
		assert capacity >= n;

		Item[] temp = (Item[]) new Object[capacity];
		for (int i = 0; i < n; i++) {
			temp[i] = a[i];
		}
		a = temp;
	}

	public void push(Item item) {
		if (n == a.length)
			resize(2 * a.length); // double size of array if necessary
		a[n++] = item; // add item
	}

	public Item pop() {
		if (isEmpty())
			throw new NoSuchElementException("Stack underflow");
		Item item = a[n - 1];
		a[n - 1] = null; // to avoid loitering
		n--;
		// shrink size of array if necessary
		if (n > 0 && n == a.length / 4)
			resize(a.length / 2);
		return item;
	}
}
```
pop方法中，a[n - 1] = null将数组中已经出栈的位置设为null，是为了避免对象游离，否则这个位置的对象虽然已经不在栈中，但还被数组引用着，导致GC无法对其回收。

##### 链表实现
栈的另外一种实现方式是采用链表，链表是一种递归的数据结构，它或者为空，或者指向一个结点的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。
构成链表的基本结点可以为：
```
private static class Node<Item> {
    public Item item;
    public Node next;
}
```
其中泛型的item变量存放数据，同样是Node类型的next变量用来指向下一个结点。将链表的头部作为栈顶，push相当于在表头插入元素，pop是从表头删除元素。
代码如下：
```
public class StackLinkedList<Item> {
	private static class Node<Item> {
		public Item item;
		public Node next;
	}

	private Node<Item> first;
	private int N;

	private boolean isEmpty() {
		return first == null;
	}

	public int size() {
		return N;
	}

	public void push(Item item) {
		Node<Item> oldFirst = first;
		first = new Node<Item>();
		first.item = item;
		first.next = oldFirst;
		N++;
	}

	public Item pop() {
		if (isEmpty())
			throw new NoSuchElementException("Stack underflow");
		Item item = first.item;
		first = first.next;
		N--;
		return item;
	}
}
```

##### 两种栈的对比
- 时间
链表实现的栈，push和pop方法的时间成本与链表的长度无关，是线性的；

#### 队列
##### 链表实现