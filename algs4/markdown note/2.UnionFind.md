
[TOC]

### 动态连通性问题
在基础部分的最后一节，作者用一个现实中应用非常广泛的案例，说明以下几点：
- 优秀的算法因为能解决实际问题而变得更为重要；
- 高效算法的代码也可以很简单；
- 理解某个实现的性能特点是一项有趣的挑战；
- 在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具；
- 迭代式改进能够让算法的效率越来越高。

动态连通性问题的输入是一列整数对，其中的每个整数都表示一个某种类型的对象，一对整数对p q可以理解为“p和q是相连的”。相连是一种等价关系，其具有：
- 自反性，p和p也是相连的；
- 对称性，p和q相连，则q和p也是相连的；
- 传递性，p和q相连，q和r相连，则p和r也是相连的。

程序的目标是过滤掉序列中无意义的整数对，当程序从输入中读取了整数对pq时，如果已知的所有整数对都不能说明p和q是相连的，那么则将这一对整数写入到输出中。如果已知的数据可以说明p和q是相连的，那么程序应该忽略pq这对整数并继续处理输入中的下一对整数。

动态连通性问题的实际应用很多，比如：检查通信网络中计算机之间是否连通、电子电路中的触点是否连接或者社交网络中的人是否相识等等。

### 实现
接下来会同一使用网络方面的术语，将整数称为*触点*、整数对成为*连接*、等价类称为*连通分量*或*分量*。
明确需要解决的问题后，就可以抽象出算法的API了，包括
```
void union(int p,int q)  //在p q之间添加一条连接，将两个分量归并
int find(int p)  //返回p所在分量的标识符
boolean connected(int p int q) //判断两个触点是否在同一分量
int count() //连通分量的数量
```

#### 通用代码
算法的基本代码如下，其中find()、union()方法在各种算法中有不同的实现。
```
public class UF {

    private int[] id;  //分量id(以触点作为索引)
    private int count; // 连通分量的数量

    public UFquickFind(int n) {
        id = new int[n];
        count=n;
        for (int i = 0; i < n; i++) {
            id[i] = i;
        }
    }

    public int find(int p) {
        //待实现
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        //待实现
    }

    public static void main(String[] args) {
        int n = StdIn.readInt();  //读取触点数量
        StdOut.println(n);
        UF uf = new UF(n);  //初始化N个分量
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();  //读取整数对
            if (uf.connected(p, q))  //是否连通,如果已经连通则忽略
                continue;
            uf.union(p, q);  //归并分量
        }
        StdOut.println(uf.count() + " components");
    }
}
```
#### Quick-Find算法
##### 实现
最直接的方法是当p和q连通时，让id[p]=id[q]，所以同一连通分量中的所有触点在id[]中的值是全部相同的。

##### 分析

#### Quick-Union算法
##### 实现

##### 分析

#### 加权Quick-Union算法
##### 实现

##### 分析

