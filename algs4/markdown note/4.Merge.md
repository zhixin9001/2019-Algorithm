
- 归并方法

- 自顶向下的归并排序
    - 实现
    - 性能分析
    - 优化：切换到插入排序
    - 优化：测试数组是否有序
- 自底向上的归并排序
    - 实现
    - 性能分析

### 归并方法
“归并”操作是将两个有序的数组合并成一个更大的有序数组，归并排序就是基于这一操作，先递归地将一个数组分成两半分别排序，然后将排序结果归并起来。
归并的代码如下：
```
private static void merge(Comparable[] a, int lo, int mid, int hi) { 
    int i = lo, j = mid + 1;
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k];
    }

    for (int k = lo; k <= hi; k++) {
        if (i > mid) {
            a[k] = aux[j++];
        } else if (j > hi) {
            a[k] = aux[i++];
        } else if (less(aux[i], aux[j])) {
            a[k] = aux[i++];
        } else {
            a[k] = aux[j++];
        }
    }
}
```
这种归并方法用了一个辅助数组aux[]，在归并时，先将待归并的元素复制到辅助数组，然后将子数组a[lo..mid]和a[mid+1..hi]归并成一个有序的数组，再将数组归并回a[]。i，j分别指向左右两个子数组的带归并元素，执行时如果左半边数组用尽，则取右半边元素，右指针加1，如果右半边数组用尽，则取左半边元素，左指针加1，如果两边数组都没用尽，则各取一个元素比较大小，将小的元素归并回原数组，同时对应的指针加1。
这个归并方法能够将两个子数组排序，然后就可以通过它将整个数组排序。

归并排序的代码实现有自顶向下和自底向上两种。
### 自顶向下的归并排序

```
public class Merge {
	private static Comparable[] aux;

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) {
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid + 1, hi);
        merge(a, lo, mid, hi);
    }

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }
}
```
其中aux为归并所需的辅助数组，在排序开始前初始化。sort(Comparable[] a, int lo, int hi)方法递归地调用merge方法，
