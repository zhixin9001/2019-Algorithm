《算法》笔记 17 - 数据压缩

- 读写二进制数据
- 基因组数据的压缩
- 游程编码
- 霍夫曼压缩
- LZW压缩

对数据压缩能够有效节省保存信息所需的空间和传输信息所需的时间。虽然计算机存储设备的成本在不断降低，但由于需要存储的数据在飞速膨胀，压缩算法仍有非常重要的意义，因为与以往相比，数据被压缩后节省的空间会更大。

### 读写二进制数据
现代计算机系统中处理的所有类型的数据最终都是用二进制表示的，可以将它们都看作一串比特的序列。

数据压缩分为无损压缩和有损压缩，前者在压缩、展开后不会丢失任何信息，但后者不然。有损压缩常被用于图像、视频、音乐的压缩。对于无损压缩算法，评价的标准为压缩率，压缩率=压缩后体积/原始体积；对于有损压缩算法，评价标准除了压缩率外，还有主观的质量感受等。
接下来只讨论无损压缩算法。

之前的算法设计输入输出时，使用的都是基于java基础方法封装的StdIn和StdOut，它们处理的是有Unicode编码的字符流；但由于压缩算法会涉及到对比特流的操作，所以接下来使用BinaryStdIn和BinaryStdOut，BinaryStdIn.readBoolean()方法会从输入中读取一个比特并返回为布尔值，BinaryStdOut.write(boolean b)方法则会向输出中写入一个比特。

### 基因组数据的压缩
接下来从初级的基因组压缩算法开始，因为表示基因组的字符集之含有A C T G四个字符。这种方法也适用于字符集大小固定且数量有限的场合。
如果将这四个字符直接用ASCII编码，需要4×8=32位，但其实只需要用两个位就可以表示4个值（2^2=4）。这样4个字符只需要2×4=8位就可以了，压缩率=8/32=25%。
由此可得对基因组数据的压缩方法：
```
public static void compress(){
    Alphabet DNA=new Alphabet("ACTG");
    String s=BinaryStdIn.readString();
    int N=s.length();
    BinaryStdOut.write(N);
    
    for(int i=0;i<N;i++){
        int d=DNA.toIndex(s.charAt(i));
        BinaryStdOut.write(d,DNA.lgR());
    }
    BinaryStdOut.close();
}
```
实例化Alphabet类时，指定字符集只有ACTG这四个，DNA.lgR()就等于2，每次输出2个比特。比如遇到字符A，就用0表示，二进制编码为00，字符B用1表示，二进制编码为01等等。

展开时，每次读取2个比特，转换为整型数字，然后根据这个数字去字符集中取得对应的字符。
```
public static void expand(){
    Alphabet DNA=new Alphabet("ACTG");
    int w=DNA.lgR();
    int N=BinaryStdIn.readInt();
    for(int i=0;i<N;i++){
        char c=BinaryStdIn.readChar(w);
        StdOut.println("c="+c);
        char e=DNA.toChar(c);
        StdOut.println("e="+e);
        BinaryStdOut.write(DNA.toChar(c));
    }
    BinaryStdOut.close();
}
```

### 游程编码
比特流中最简单的冗余形式就是一长串重复的比特，游程编码就是利用这种冗余来压缩数据的经典方法，在对位图的压缩中有很好的效果。

#### 位图
位图经常用于保存图像和扫描文档，下面是一张最简单的位图，分辨率为32×48，图像为一个“q”字符，用按行排列的比特流来表示位图数据，所以这张简单的位图是没有颜色信息的，或者说只有两种颜色。
```
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000011111110000000000
00000000000011111111111111100000
00000000001111000011111111100000
00000000111100000000011111100000
00000001110000000000001111100000
00000011110000000000001111100000
00000111100000000000001111100000
00001111000000000000001111100000
00001111000000000000001111100000
00011110000000000000001111100000
00011110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111110000000000000001111100000
00111111000000000000001111100000
00111111000000000000001111100000
00011111100000000000001111100000
00011111100000000000001111100000
00001111110000000000001111100000
00001111111000000000001111100000
00000111111100000000001111100000
00000011111111000000011111100000
00000001111111111111111111100000
00000000011111111111001111100000
00000000000011111000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000001111100000
00000000000000000000011111110000
00000000000000000011111111111100
00000000000000000111111111111110
00000000000000000000000000000000
00000000000000000000000000000000
```

取这种位图中的第5行来分析
```
00000000001111000011111111100000
```
这条长度32的字符串中，含有：10个0 - 4个1 - 4个0 - 9个1 - 5个0。所有的比特字符串都是类似这样，0和1交替出现，所以对于这条字符串，就可以编码为10，4，4，9，5，如果用4比特表示长度，并以连续的0作为开头，就可以得到一个20为长的字符串（不包含逗号）：1010,0100,0100,1001,0101。压缩率=20/32=62.5%。

