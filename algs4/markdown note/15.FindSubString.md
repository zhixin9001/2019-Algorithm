《算法》笔记 15 - 子字符串查找

- 暴力子字符串查找算法
- Knuth-Morris-Pratt算法
- Boyer-Moore算法
- Rabin-Karp指纹字符串算法

字符串的一种基本操作就是子字符串查找。比如在文本编辑器或是浏览器中查找某个单词时，就是在查找子字符串。子字符串的长度（可能为100或1000）相对于整个文本的长度（可能为100万甚至是10亿）来说一般是很短的，在如此多的字符中找到匹配的模式是一个很大的挑战，为此计算机科学家们发明了多种有趣、经典且高效的算法。

### 暴力子字符串查找算法
要解决这个问题，首先想到的是暴力查找的方法，在文本中模式可能出现匹配的任何地方检查是否匹配。
#### 隐式回退
首先是隐式回退的实现方式，之所以叫隐式回退，在与显式回退的实现对比后就明白原因了。
```
public static int search(String pat, String txt) {
    int patL = pat.length();
    int txtL = txt.length();

    for (int i = 0; i <= txtL - patL; i++) {
        int j;
        for (j = 0; j < patL; j++)
            if (txt.charAt(i + j) != pat.charAt(j))
                break;
        if (j == patL)
            return i;
    }
    return txtL;
}
```
用一个索引i跟踪文本，另一个索引j跟踪模式。对于每个i，代码首先将j重置为0，并不断把它加1，直到找到了一个不匹配的字符，或者j增加到patL，此时就找到了匹配的子字符串。

#### 性能
在一般情况下，索引j增长的机会很少，绝大多数时候在比较第一个字符是就会产生不匹配。
在长度为N的文本中，查找长度为M的子字符串时：
- 在最好情况下，对于每个i，在索引j=0时就发现了不匹配，一共需要进行N次字符比较；
- 在最坏的情况下，对于前N-1个i，索引j都需要增加到M-1次，才会发现不匹配，最后一次匹配，比如文本和模式都是一连串的A接一个B。这种情况下，对于N-M+1个可能的匹配位置，都需要M次比较，一共需要进行M*(N-M+1)次比较，因为N远大于M，所以忽略小数值后结果为~NM。

#### 显式回退
```
public static int search1(String pat, String txt) {
    int j, patL = pat.length();
    int i, txtL = txt.length();

    for (i = 0, j = 0; i <= txtL && j < patL; i++) {
        if (txt.charAt(i) == pat.charAt(j))
            j++;
        else {
            i -= j;
            j = 0;
        }
    }
    if (j == patL)
        return i - patL;
    else
        return txtL;
}
```
与隐式回退一样，也使用了索引i和j分别跟踪文本和模式的字符，但这里的i指向的是匹配过的字符序列的末端，所以这里的i相当与隐式回退中的i+j，如果字符不匹配，就需要回退i和j的位置，将j回退为0，指向模式的开头，将i指向本次匹配的开始位置的下一个字符。
隐式回退的实现方式中，匹配位置的的末端字符是通过i+j指定的，所以只需要将j重新设为0，就实现了文本和模式字符的回退。

### Knuth-Morris-Pratt算法
暴力算法在每次出现不匹配时，都会回退到本次匹配开始位置的下一个字符，但其实在不匹配时，就能知道一部分文本的内容，因此可以利用这些信息减少回退的幅度，Knuth-Morris-Pratt算法（简称KMP算法）就是基于这种思想。
比如，假设文本只有A和B构成，那么在查找模式字符串为B A A A A A A A时，如果在匹配到第6个字符时出现不匹配，此时可以确定文本中的前6个字符就是B A A A A B，接下来不需要回退i，只需将i+1, j+2后，继续和模式的第二个字符匹配即可，因为模式的第一个字符是B，而上一次匹配失败的末尾字符也是B。
而对于文本A A B A A B A和模式A A B A A A，在文本的第6个字符处发现不匹配后，应该从第4个字符开始重新匹配，这样就不会错过已经匹配的部分了。
KMP算法的主要思想就是提前判断如何重新开始查找，而这种判断只取决于模式本身。
#### 确定有限状态自动机
KMP算法中不会回退文本索引i，而是使用一个二维数组dfa来记录匹配失败时模式索引j应该回退多远。对于每个字符c，在比较了c和pat.charAt(j)之后，dfa\[c\]\[i\]表示的是应该和下个文本字符比较的模式字符的位置。
这个过程实际上是对确定有限状态自动机（DFA）的模拟，dfa数组定义的正是一个确定有限状态自动机。DFA由状态（数字标记的圆圈）和转换（带标签的箭头）组成，模式中的每个字符都对应着一个状态，用模式字符串的索引值表示。
【DFA】图和数组
在标记为j的状态中检查文本中的第i个字符时，自动机会沿着转换dfa\[txt.charAt(i)\][j]前进并继续将i+1，对于一个匹配的转换，就向右移动一位，对于一个不匹配的智慧，就根据自动机的指示回退j。自动机从状态0开始，如果到达了最终的停止状态M，则查找成功。

#### DFA的构造
DFA是KMP算法的核心，构造给定模式对应的DFA也是这个算法的关键问题。DFA指示了应该如何处理下一个字符。如果在pat.charAt(j)处匹配成功，DFA应该前进到状态j+1。但如果匹配失败，DFA会从已经构造过的模式中获取到需要的信息，以模式 A B A B A C的构造过程举例：
下面表格表示dfa\[\]\[\]，横向表头表示模式字符，括号中是当前的状态。

1.初始状态，各位置都是0：
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|0|0|0|0|0|0|
B|0|0|0|0|0|0|
C|0|0|0|0|0|0|
2.先看字符匹配成功时的情况，这时对应的状态会指向下一个状态：
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|0|3|0|5|0|
B|0|2|0|4|0|0|
C|0|0|0|0|0|6|

3.在状态0，匹配失败时，无论是B还是C都退到初始状态，重新开始；
4.在状态1，匹配失败时，如果此时的字符为A，则文本为A A，可以跳过状态0，直接到状态1，与A(0)行为一致，所以将A(0)的值复制到B(1)，在DFA中对应的值也为1；而对于字符C，文本为A C，只能退回到状态0,重新开始
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|1|||||
B|0|2|||||
C|0|0|||||

5.在状态2，匹配失败时，如果此时的字符为B，则文本为A B B，回到状态0；如果是字符C，文本为A B C，也只能退回到状态0。
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|1|3||||
B|0|2|0||||
C|0|0|0||||

6.在状态3，匹配失败时，如果此时的字符为A，则文本为A B A A，直接到状态1；如果是字符C，文本为A B A C，回到状态0
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|1|3|1|||
B|0|2|0|4|||
C|0|0|0|0|||

7.在状态4，匹配失败时，如果此时的字符为B，则文本为A B A B B，回到状态0；如果是字符C，文本为A B A B C，回到状态0
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|1|3|1|5||
B|0|2|0|4|0||
C|0|0|0|0|0||

8.在状态5，匹配失败时，如果此时的字符为a，则文本为A B A B A A，回到状态1；如果是字符B，文本为A B A B A B，回到状态4，因为前面的A B A B都是匹配的，可以跳过。
-|A(0)|B(1)|A(2)|B(3)|A(4)|C(5)
-:|:-:|:-:|:-:|:-:|:-:|:-:
A|1|1|3|1|5|1|
B|0|2|0|4|0|4|
C|0|0|0|0|0|6|

通过以上过程可知，在计算状态为j的DFA时，总能从尚不完整、已经计算完成的j-1个状态中得到所需的信息。
```
dfa[pat.charAt(0)][0] = 1;
for (int X = 0, j = 1; j < M; j++) {
    for (int c = 0; c < R; c++)
        dfa[c][j] = dfa[c][X];
    dfa[pat.charAt(j)][j] = j + 1;
    X = dfa[pat.charAt(j)][X];
}
```
代码中，用X维护了每次重启时的状态，然后具体的做法是：
- 匹配失败时，将dfa\[\]\[X\]复制到dfa\[\]\[j\]；
- 匹配成功时，将dfa\[pat.chatAt(j)\]\[j\]的值设为j+1；
- 将X更新为dfa\[pat.charAt(j)\]\[X\]

初始化完成dfa后，查找的代码为：
```
public int search(String txt) {
    int i, j, N = txt.length(), M = pat.length();
    for (i = 0, j = 0; i < N && j < M; i++) {
        j = dfa[txt.charAt(i)][j];
    }
    if (j == M)
        return i - M;
    else
        return N;
}
```

#### 性能
在长度为N的文本中，查找长度为M的子字符串时，KMP算法会先初始化dfa，访问模式字符串中的每个字符一次，查找时在最坏情况下，会把文本中的字符都访问一次，所以KMP算法访问的字符最多N+M个。





### Boyer-Moore算法
### Rabin-Karp指纹字符串算法