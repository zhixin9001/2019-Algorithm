《算法》笔记 11 - 最小生成树

- 最小生成树的应用
- 切分定理
- 贪心算法
- 加权无向图的数据结构
- Prim算法
- Kruskal算法

加权图是一种为每条边关联一个权值的图模型，这种图可以表示许多应用，比如在一副航空图中，边表示航线，权值就可以表示距离或费用；在一副电路图中，边表示导线，权值就可以表示导线的长度、成本或阻抗。在这些情形中，最令人感兴趣的便是如何将成本最小化。*最小生成树*就是用于在加权无向图中解决这类问题的。最小生成树相关的算法在通信、电子、水利、网络、交通灯行业具有广泛的应用。

图的*生成树*是它的一颗含有其所有顶点的无环连通子图，一副加权无向图的*最小生成树*(Minimum spanning tree)是它的一颗*权值*（树中所有边的权值之和）最小的生成树。


###
切分定理

图的一种*切分*是将图的所有顶点分为两个非空且不重复的集合。*横切边*是一条连接两个属于不同集合顶点的边。
通常通过指定一个顶点集并隐式地认为它的补集为另一个顶点集来指定一个切分。这样，一条横切边就是连接该集合的一个顶点和不在该集合中的另一个顶点的一条边。
切分定理：在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。
要证明切分定理，需要知道树的两个重要性质：
- 用一条边连接树中的任意两个顶点都会产生一个新的环；
- 从树中删去任意条边都将会得到两颗独立的树。
接下来用反证法证明切分定理：令e为权值最小的横切边，T为图的最小生成树，假设T不包含e，那么将e加入T得到的图必然含有一条经过e的环，且这个环至少还有另一条横切边——设为f，f的的权重必然大于e（因为e的权重是最小的且图中所有边的权值都不相同）。那么删去f保留e就可以得到一颗权值更小的树，这与假设矛盾。

###
贪心算法
切分定理是所有解决最小生成树问题算法的基础，这些算法都是一种贪心算法的特殊情况，贪心算法是一类在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。解决最小生成树问题时，会使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法之间的区别之处在于保存切分和判定权重最小的横切边的方式。
*最小生成树的贪心算法*：一副加权无向图中，在初始状态下所有边均为灰色，找到一种切分，它产生的横切边均部位黑色，将它权重最小的横切边标记为黑色，如此反复，直到标记了V-1条黑色边为止。
其中V为图中顶点的数量，那么要将这些顶点全部连接，至少需要V-1条边。根据切分定理，所有被标记为黑色的边都属于最小生成树，如果黑色边的数量小于V-1，那么必然还存在不会产生黑色边的切分，只要找够V-1条黑色边，最小生成树就完成了。

###
加权无向图的数据结构
加权无向图的数据结构没有沿用之前无向图的数据结构，而是重新定义了Edge和EdgeWeightedGraph类，分别用于表示*带权重的边*和*加权无向图*。

####

```
public class Edge implements Comparable<Edge> {
    private final int v; 
    private final int w; 
    private final double weight; 

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return this.weight;
    }

    public int either() {
        return this.v;
    }

    public int other(int vertex) {
        if (v == vertex)
            return w;
        if (w == vertex)
            return v;
        else
            throw new RuntimeException("Inconsistent edge");
    }

    public int compareTo(Edge that) {
        if (this.weight() < that.weight())
            return -1;
        else if (this.weight() > that.weight())
            return 1;
        else
            return 0;
    }

    public String toString() {
        return String.format("%d-%d %.2f", v, w, weight);
    }
}
```
either和other方法可以返回边连接的两个端点，weight表示边的权重。

```
public class EdgeWeightedGraph {
    private static final String NEWLINE = System.getProperty("line.separator");
    private final int V; // vertex
    private int E; // edge
    private Bag<Edge>[] adj;

    public EdgeWeightedGraph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Edge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Edge>();
        }
    }

    public EdgeWeightedGraph(In in) {
        this(in.readInt());
        int E = in.readInt();
        for (int i = 0; i < E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            double weight = in.readDouble();
            Edge e = new Edge(v, w, weight);
            addEdge(e);
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(Edge e) {
        int v = e.either(), w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    public Iterable<Edge> adj(int v) {
        return adj[v];
    }

    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " vertices, " + E + " edges " + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (Edge w : adj[v]) {
                s.append(w + " | ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

    public Bag<Edge> edges() {
        Bag<Edge> b = new Bag<Edge>();
        for (int v = 0; v < V; v++) {
            for (Edge w : adj[v]) {
                b.add(w);
            }            
        }
        return b;
    }
```

EdgeWeightedGraph与无向图中的Graph非常类似，只是用Edge对象替代了Graph中的整数来作为链表的结点。adj(int v)方法可以根据顶点而索引到对应的邻接表，每条边都会出现两次，如果一条边连接了顶点v和w，那么这条边会同时被添加到v和w对应的链接表中。

