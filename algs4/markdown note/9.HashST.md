散列表

- 散列函数
    - 查找
- 基于拉链法的散列表
    - 查找
    - 插入

- 基于线性探测法的散列表

如果所有的键都是小整数，则可以用一个数组来作为无序的符号表，将键作为数组的索引，数组中对应的位置保存的值就是这个键对应的值。这样就可以快速访问任意的键了。散列表就是基于这种方法，但散列表能够处理更加复杂的类型的键。

使用散列的查找算法分为两步：第一步需要通过散列函数将键转换为数组的索引，理想情况下，根据所以就可以再获取键对应的值了，但实际上会存在多个键的散列值指向同一个索引的情况，这时就需要进行第二步：处理碰撞冲突。


散列函数
散列函数可以将键转化为数组的所以。如果数组的容量为M，则散列函数就应该能够将任意键转换为数组范围内的所有。合格的散列函数需要满足如下条件：
- 一致性，等价的键必然产生相等的散列值；
- 高效性，散列函数应该计算简便，不会耗时太多
- 均匀性，均匀的散列所有的键

Java为每种数据类型都内置了hashCode方法，它的返回值是一个32位的整数。每一种数据类型的hashCode方法都与equals()方法一致，即如果a.equals(b)，则a.hashCode()=b.hashCode()，但如果a.hashCode()=b.hashCode()，a不一定与b相等，因为会有碰撞问题，还需要用equals()方法进行判断。



散列表在时间和空间之间做了权衡。如果没有内存限制，即使数据量特别大，也可以直接将键作为一个超大数组的索引，这样只需访问内存一次就可以完成查找；如果没有时间限制，也可以使用无序数组存储数据，然后顺序查找。而散列表则使用了适度的空间和时间并在这两个极端之间取得了一种平衡。通过调整散列表的参数就可以在空间和时间之间做出取舍。







