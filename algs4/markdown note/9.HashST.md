散列表

- 散列函数
    - 查找
- 基于拉链法的散列表
    - 查找
    - 插入

- 基于线性探测法的散列表

如果所有的键都是小整数，则可以用一个数组来作为无序的符号表，将键作为数组的索引，数组中对应的位置保存的值就是这个键对应的值。这样就可以快速访问任意的键了。散列表就是基于这种方法，但散列表能够处理更加复杂的类型的键。

使用散列的查找算法分为两步：第一步需要通过散列函数将键转换为数组的索引，理想情况下，根据所以就可以再获取键对应的值了，但实际上会存在多个键的散列值指向同一个索引的情况，这时就需要进行第二步：处理碰撞冲突。


#### 散列函数
散列函数可以将键转化为数组的所以。如果数组的容量为M，则散列函数就应该能够将任意键转换为数组范围内的所有。合格的散列函数需要满足如下条件：
- 一致性，等价的键必然产生相等的散列值；
- 高效性，散列函数应该计算简便，不会耗时太多
- 均匀性，均匀的散列所有的键

Java为每种数据类型都内置了hashCode方法，它的返回值是一个32位的整数。每一种数据类型的hashCode方法都与equals()方法一致，即如果a.equals(b)，则a.hashCode()=b.hashCode()，但如果a.hashCode()=b.hashCode()，a不一定与b相等，因为会有碰撞问题，还需要用equals()方法进行判断。默认的hashCode方法会返回对象的内存地址，但这只适用于很少的情况，Java为很多常用的数据类型重写了hashCode()方法，比如String、Integer、Double、File等等。
在实现散列表时，需要将键映射为数组的索引，以下hash()方法是基于hashCode()的：
```
private int hash(Key key) {
    return (key.hashCode() & 0x7fffffff) % m;
}
```
hashCode()的返回值是32位整数，将其与0x7fffffff与运算，可以屏蔽符号位，变为一个31位的非负整数，然后与数组容量m取余，可以保证散列值都落在数组的索引范围内。m为素数时，散列值会更均匀。

#### 基于拉链法的散列表
在散列函数将键转化为数组索引后，接下来要做的就是处理碰撞冲突。一种方法是将数组中的每个元素都指向一条链表，链表中的每个节点都存储了散列值为该元素的索引的键值对。这种方法便是*拉链法*。要从基于拉链法的散列表中查找一个元素，首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。为了保证高效性的查找，数组的容量M值应该足够大，这样得到的链表平均长度会比较短。

```
public class SeparateChainingHashST<Key, Value> {
    private static final int INIT_CAPACITY = 4;

    private int n; // count of k-v pairs
    private int m; // size of hashtable
    private SequentialSearchST<Key, Value>[] st;

    public SeparateChainingHashST() {
        this(INIT_CAPACITY);
    }

    public SeparateChainingHashST(int M) {
        this.m = M;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
        for (int i = 0; i < M; i++) {
            st[i] = new SequentialSearchST();
        }
    }

    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % m;
    }

    public Value get(Key key) {
        if (key == null)
            throw new IllegalArgumentException("argument to get() is null");
        return (Value) st[hash(key)].get(key);
    }

    public void put(Key key, Value val) {
        if (key == null)
            throw new IllegalArgumentException("first argument to put() is null");

        // if (val == null) {
        //     delete(key);
        //     return;
        // }
        // double table size if average length of list >= 10
        if (n >= 10 * m)
            resize(2 * m);

        int i = hash(key);
        if (!st[i].contains(key))
            n++;
        st[i].put(key, val);
    }

    // public void delete(Key key) {
    //     if (key == null)
    //         throw new IllegalArgumentException("argument to delete() is null");

    //     int i = hash(key);
    //     if (st[i].contains(key))
    //         n--;
    //     st[i].delete(key);

    //     if (m < INIT_CAPACITY && size() < 2 * m)
    //         resize(m / 2);
    // }

    public void resize(int chains) {
        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys()) {
                temp.put(key, st[i].get(key));
            }
        }
        this.m = temp.m;
        this.n = temp.n;
        this.st = temp.st;
    }
}

```















散列表在时间和空间之间做了权衡。如果没有内存限制，即使数据量特别大，也可以直接将键作为一个超大数组的索引，这样只需访问内存一次就可以完成查找；如果没有时间限制，也可以使用无序数组存储数据，然后顺序查找。而散列表则使用了适度的空间和时间并在这两个极端之间取得了一种平衡。通过调整散列表的参数就可以在空间和时间之间做出取舍。







